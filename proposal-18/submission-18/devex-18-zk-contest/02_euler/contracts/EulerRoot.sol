/*
  Implementation of contract EulerRoot
 */

pragma ton-solidity >= 0.32.0;

pragma AbiHeader expire;
pragma AbiHeader pubkey;

import "./IEulerRoot.sol";
import "EulerProblem.sol";
import "EulerUser.sol";
import "RecoverablePubkey.sol.gen";

contract EulerRoot is IEulerRoot, RecoverablePubkey {

  uint64 constant EXN_AUTH_FAILED = 100 ;
  uint64 constant EXN_NOT_ENOUGH_VALUE = 101 ;

  /// @dev This event is emitted everytime a user solves a problem
  event ProblemSolved( uint32 problem, uint256 pubkey );

  // The owner of this contract, who can create new EulerProblem
  // contracts
  uint256 g_owner ;
  // The code of EulerProblem contracts
  TvmCell g_problem_code ;
  // The code of EulerUser contracts
  TvmCell g_user_code ;

  /// @dev The user must only provide the codes of EulerProblem and
  /// EulerUser contracts
  constructor( TvmCell problem_code, TvmCell user_code ) public {
    require( msg.pubkey() == tvm.pubkey(), EXN_AUTH_FAILED );
    require( address(this).balance >= 2 ton, EXN_NOT_ENOUGH_VALUE );
    tvm.accept();
    g_owner = msg.pubkey() ;
    g_problem_code = problem_code ;
    g_user_code = user_code ;
  }


  /// @dev Deploys a EulerProblem contract for a new Euler problem. Only the
  ///   owner of the EulerRoot can call this function.
  /// @param problem The number of the problem
  /// @param verifkey The Groth16 verification key of the problem
  /// @param zip_provkey A compressed version of the Groth16 proving key
  ///    of the problem, used to create a submission locally
  /// @param nonce The nonce that the user must provide with his submission
  /// @param title The title of the problem
  /// @param description The description of the problem
  /// @param url The link to the problem official description
  function new_problem( uint32 problem,
                        bytes verifkey,
                        bytes zip_provkey,
                        string nonce,
                        string title,
                        string description,
                        string url)
    public view returns ( address addr )
  {
    require( g_owner == msg.pubkey(), EXN_AUTH_FAILED );
    require( address(this).balance > 1 ton, EXN_NOT_ENOUGH_VALUE );
    tvm.accept() ;

    addr = new EulerProblem {
      value: 1 ton,
      pubkey: tvm.pubkey() ,
      code: g_problem_code ,
      varInit: {
        s_problem: problem ,
        s_root_contract: this
      }
    }( verifkey, zip_provkey, nonce, title, description, url );
  }

  /// @dev This function deploys a EulerUser contract associated with a
  ///   given public key. Anybody can call this function from a multisig.
  /// @param pubkey: The user pubkey 
  function new_user( uint256 pubkey ) public view returns ( address addr )
  {
    require( msg.value >= 1 ton, EXN_AUTH_FAILED );
    addr = new EulerUser {
      value: msg.value - 0.1 ton,
      pubkey: pubkey ,
      code: g_user_code ,
      varInit: {
        s_root_contract: this
      }
    }() ;

  }


  /// @dev Returns the address of the EulerProblem contract associated
  ///   with a given problem number. The contract exists only if
  ///   'new_problem' has been called before.
  /// @param problem : the number of the problem
  function problem_address( uint32 problem ) public view
    returns ( address addr )
  {
    TvmCell stateInit = tvm.buildStateInit({
      contr: EulerProblem ,
      pubkey: tvm.pubkey() ,
      code: g_problem_code ,
      varInit: {
        s_problem: problem ,
        s_root_contract: this
      }
    });
    addr = address(tvm.hash(stateInit));
  }

  /// @dev returns the address of the EulerUser contract associated
  /// with a given pubkey. The contract only exists if 'new_user' has
  /// been called before.
  function user_address( uint256 pubkey ) public view
    returns ( address addr )
  {
    TvmCell stateInit = tvm.buildStateInit({
      contr: EulerUser ,
      pubkey: pubkey ,
      code: g_user_code ,
      varInit: {
        s_root_contract: this
      }
    });
    addr = address(tvm.hash(stateInit));    
  }

  /// @dev submits a solution to a given problem, using a proof
  ///   generated by euler-client C++ program, associated with the
  ///   given pubkey. The proof will fail if another pubkey is
  ///   provided.
  /// @param problem: number of the problem
  /// @param proof: the 'proof.bin' generated by euler-client
  /// @param pubkey: the pubkey of the user, as used when generating
  ///   'proof.bin'
  function submit( uint32 problem,
                   bytes proof,
                   uint256 pubkey) public view override
  {
    address addr = problem_address( problem );
    EulerProblem( addr ).submit
      { value:0, flag: 64} ( problem, proof, pubkey );
  }

  /// @dev updates the Blueprint circuit associated with a given problem
  /// @param problem: the number of the problem
  /// @param verifkey: the new verification key of the circuit
  /// @param zip_provkey: the new proving key of the circuit to be used to
  ///   generate submission proofs
  /// @param nonce: the nonce to be used to generate submission proofs
  function update_circuit( uint32 problem,
                           bytes verifkey,
                           bytes zip_provkey,
                           string nonce ) public view
  {
    require( g_owner == msg.pubkey(), EXN_AUTH_FAILED );
    tvm.accept();
    address addr = problem_address( problem );
    EulerProblem( addr ).update_circuit
      { value:0.2 ton } ( verifkey, zip_provkey, nonce );
  }

  /// @dev Updates the description of a problem. Only called by the owner of
  ///   the EulerRoot contract.
  /// @param problem: the number of the problem
  /// @param title: the new title of the problem or empty string
  /// @param description: the new description of the problem or empty string
  /// @param url: the new url of the problem or empty string
  function update_problem( uint32 problem,
                           string title,
                           string description,
                           string url ) public view
  {
    require( g_owner == msg.pubkey(), EXN_AUTH_FAILED );
    tvm.accept();
    address addr = problem_address( problem );
    EulerProblem( addr ).update_problem
      { value:0.2 ton } ( title, description, url );
  }


  /// @dev This function is called by a EulerProblem when a user
  /// successfully submitted a solution. The function verifies that
  /// the sender is indeed an EulerProblem contract as expected. The
  /// function emits en event and calls the EulerUser contract to
  /// record the information
  /// @param problem: the number of the problem
  /// @param pubkey: the user pubkey who successfully solved the problem
  function has_solved( uint32 problem,
                       uint256 pubkey ) public override
  {
    address addr = problem_address( problem ) ;
    require( addr == msg.sender, EXN_AUTH_FAILED );

    emit ProblemSolved( problem, pubkey );
    addr = user_address( pubkey );
    EulerUser( addr ).has_solved{ value:0, flag: 64 }( problem );
  }

  /// @dev This get-method function is used to recover information on
  ///  this contract
  function get() public view returns
    ( uint256 owner, uint256 problem_code_hash, uint256 user_code_hash )
  {
    owner = g_owner ;
    problem_code_hash = tvm.hash ( g_problem_code );
    user_code_hash = tvm.hash ( g_user_code );
  }

  /// @dev This internal function is used to change the owner of the
  ///   contract using the pincode-client smart contract (described in
  ///   03-pincode section)
  function recover_pubkey ( uint256 oldkey,
                            uint256 newkey) internal override
  {
    if( oldkey == g_owner ){
      g_owner = newkey;
    }
  }

}

