{
	".source.ton-solidity": {
		"spdx license": {
			"prefix": "spdx", 
			"body": "// SPDX-License-Identifier: MIT",
			"description": "SPDX License"
		},
		"pragma solidity":{
			"prefix": "pragmа solidity",
			"body": "pragma solidity ${1:version};"
		},
		"pragma ton-solidity":{
			"prefix": "pragmt",
			"body": "pragma ton-solidity >= ${1:version};",
			"description":[
				"It's used to reject compilation source file with some versions of the compiler.\n",
				"Examples:",
				"pragma ton-solidity >= 0.35.5; \n// Check compiler version is at least 0.35.5",
				"pragma ton-solidity ^ 0.35.5; \n// Check compiler version is at least 0.35.5 and less 0.36.0",
				"pragma ton-solidity < 0.35.5; \n// Check compiler version is less 0.35.5"
			]
		},
		"pragma ignoreIntOverflow":{
			"prefix": "pragmа ignoreIntOverflow",
			"body": "pragma ignoreIntOverflow;",
			"description": "Turns off binary operation result overflow check."
		},
		"pragma AbiHeader":{
			"prefix": "pragmа AbiHeader",
			"body": "pragma AbiHeader ${1|time,pubkey,expire|};",
			"description": [
				"Force message forming utility to fill \nan appropriate field(s) in the header of \nthe exteranl inbound message to be \nsent to this contract:\n",
				" * pubkey - public key by which the message can be signed;",
				" * time - local time at what message was created;",
				" * expire - time at which message should be meant as expired."
			]
		},
		"pragma msgValue":{
			"prefix": "pragma msgValue",
			"body": "pragma msgValue ${1: value};",
			"description": [
				"pragma msgValue <value>;\n",
				"Allows specifying default value in nanotons \nattached to the internal messages that \ncontract sends to call another contract. \nIf it's not specified, this value is set \nto 10 000 000 nanotons.",
				"Examples:",
				"pragma msgValue 123456789;",
				"pragma msgValue 1 ton;"
			]
		},
		"import contract": {
			"prefix": "imp",
			"body": "import '${1:contract}';"
		},
        "contract declaration": {
			"prefix": "con",
			"body": "contract ${1:Name} {\n\t$0\n}"
		},
		"library declaration": {
			"prefix": "lib",
			"body": "library ${1:Name} {\n\t$0\n}"
		},
		"interface declaration": {
			"prefix": "interf",
			"body": "interface ${1:Name} {\n\t$0\n}"
		},
		"enum declaration": {
			"prefix": "enum",
			"body": "enum ${1:Name} {${2:item1}, ${3:item2} }"
		},
        "mapping declaration":{
            "prefix": "map",
			"body": "mapping (${1:type1}=>${2:type2}) ${3:name};"
		},
		"constructor declaration": {
			"prefix": "const",
			"body": "constructor (${1:type} ${2:name}) public {\n\t$0\n}"
		},
        "function declaration": {
			"prefix": "func",
			"body": "function ${1:name}(${2:type} ${3:name}) {\n\t$0\n}"
		},
        "function return declaration": {
			"prefix": "funcr",
			"body": "function ${1:name}(${2:type} ${3:name}) returns (${4:type} ${5:name}) {\n\t$0\n}"
		}
        ,
        "function view declaration": {
			"prefix": "funcrview",
			"body": "function ${1:name}(${2:type} ${3:name}) view public returns (${4:type} ${5:name}) {\n\t$0\n}"
        },
        "event declaration": {
			"prefix": "ev",
			"body": "event ${1:name}(${2:type} ${3:name} $0);"
        },
		"error declaration": {
			"prefix": "error",
			"body": "error ${1:name}(${2:type} ${3:name} $0);"
        },
        "modifier declaration": {
			"prefix": "mod",
			"body": "modifier ${1:name}($2) {\n\t$0_\n}"
        },
        "if else statement": {
			"prefix": "ife",
			"body": "if (${1:condition}) {\n\t$2\n} else {\n\t$0\n}"
		},
        "for statement": {
			"prefix": "for",
			"body": "for (uint256 ${1:index} = 0; $1 < ${2:array}.length; $1${3:++}) {\n\t$0\n}"
		},
		"unchecked" : {
			"prefix": "unchecked",
			"body": "unchecked {\n\t$0\n}"
		},
		"natspec contract": {
			"prefix": "\/\/\/nat_contract",
			"body": "\/\/\/ @title A title that should describe the contract\/interface\r\n\/\/\/ @author The name of the author\r\n\/\/\/ @notice Explain to an end user what this does\r\n\/\/\/ @dev Explain to a developer any extra details",
			"description": "natspec for contract"
		},
		"natspec variable": {
			"prefix": "\/\/\/nat_statevariable",
			"body": "\/\/\/ @notice Explain to an end user what this does\r\n\/\/\/ @dev Explain to a developer any extra details\r\n\/\/\/ @return Documents the return variables of a contract\u2019s function state variable\r\n\/\/\/ @inheritdoc\tCopies all missing tags from the base function (must be followed by the contract name)",
			"description": "natspec for state variable"
		},
		"natspec function": {
			"prefix": "\/\/\/nat_function",
			"body": "\/\/\/ @notice Explain to an end user what this does\r\n\/\/\/ @dev Explain to a developer any extra details\r\n\/\/\/ @param Documents a parameter just like in doxygen (must be followed by parameter name)\r\n\/\/\/ @return Documents the return variables of a contract\u2019s function state variable\r\n\/\/\/ @inheritdoc\tCopies all missing tags from the base function (must be followed by the contract name)",
			"description": "natspec for function"
		},
		"natspec event": {
			"prefix": "\/\/\/nat_event",
			"body": "\/\/\/ @notice Explain to an end user what this does\r\n\/\/\/ @dev Explain to a developer any extra details\r\n\/\/\/ @param Documents a parameter just like in doxygen (must be followed by parameter name)",
			"description": "natspec for event"
		},		
		"<TvmTvmCell>.depth": {
			"prefix": ".depth",
			"body": ".depth()",
			"description": [
				"<TvmCell>.depth() returns(uint64);",
				"Returns the depth of TvmCell c. If c has no references, then d = 0; otherwise d is one plus the maximum of depths of cells referred to from c. If c is a Null instead of a Cell, returns zero."
			]
		},
		"<TvmCell>.dataSize": {
			"prefix": ".dataSize",
			"body": ".dataSize(${uint n})",
			"description": [
				"<TvmCell>.dataSize(uint n) returns (uint /*cells*/, uint /*bits*/, uint /*refs*/);",
				"Returns the count of distinct cells, data bits in the distinct cells and cell references in the distinct cells. If count of the distinct cells exceeds n+1 then a cell overflow exception (8) is thrown. This function is a wrapper for opcode \"CDATASIZE\" "
			]
		},
		"<TvmCell>.dataSizeQ": {
			"prefix": ".dataSizeQ",
			"body": ".dataSizeQ(${uint n})",
			"description": [
				"<TvmCell>.dataSizeQ(uint n) returns (optional(uint /*cells*/, uint /*bits*/, uint /*refs*/));",
				"Returns the count of distinct cells, data bits in the distinct cells and cell references in the distinct cells. If count of the distinct cells exceeds n+1 then this function returns an optional that has no value. This function is a wrapper for opcode \"CDATASIZEQ\" "
			]
		},
		"<TvmCell>.toSlice": {
			"prefix": ".toSlice",
			"body": ".toSlice()",
			"description": [
				"<TvmCell>.toSlice() returns (TvmSlice);",
				"Converts the cell to a slice."
			]
		},
		"<TvmSlice>.empty": {
			"prefix": ".empty",
			"body": ".empty()",
			"description": [
				"<TvmSlice>.empty() returns (bool);\n",
				"Checks whether a Slice is empty \n(i.e., contains no bits of data and no cell references)."
			]
		},
		"<TvmSlice>.size": {
			"prefix": ".size",
			"body": ".size()",
			"description": [
				"<TvmSlice>.size() returns (uint16 /*bits*/, uint8 /*refs*/);",
				"Returns number of data bits and references in the slice."
			]
		},
		"<TvmSlice>.dataSize": {
			"prefix": ".dataSize",
			"body": ".dataSize(${uint n})",
			"description": [
				"<TvmSlice>.dataSize(uint n) returns (uint /*cells*/, uint /*bits*/, uint /*refs*/);",
				"Returns the count of distinct cells, data bits in the distinct cells and cell references in the distinct cells. If count of the distinct cells exceeds n+1 then a cell overflow exception (8) is thrown. Note that the returned count of distinct cells does not take into account the cell that contains the slice itself. This function is a wrapper for opcode SDATASIZE"
			]
		},
		"<TvmSlice>.dataSizeQ": {
			"prefix": ".dataSizeQ",
			"body": ".dataSizeQ(${uint n})",
			"description": [
				"<TvmSlice>.dataSizeQ(uint n) returns (optional(uint /*cells*/, uint /*bits*/, uint /*refs*/));",
				"Returns the count of distinct cells, data bits in the distinct cells and cell references in the distinct cells. If count of the distinct cells exceeds n+1 then this function returns an optional that has no value. Note that the returned count of distinct cells does not take into account the cell that contains the slice itself. This function is a wrapper for opcode SDATASIZEQ"
			]
		},
		"<TvmSlice>.bits": {
			"prefix": ".bits",
			"body": ".bits()",
			"description": [
				"<TvmSlice>.bits() returns (uint16);",
				"Returns number of references in the slice."
			]
		},
		"<TvmSlice>.refs": {
			"prefix": ".refs",
			"body": ".refs()",
			"description": [
				"<TvmSlice>.refs() returns (uint8);",
				"Returns number of references in the slice."
			]
		},
		"<TvmSlice>.bitsAndRefs": {
			"prefix": ".bitsAndRefs",
			"body": ".bitsAndRefs()",
			"description": [
				"<TvmSlice>.bitsAndRefs() returns (uint16, uint8);",
				"Returns number of data bits and references in the slice."
			]
		},
		"<TvmSlice>.depth": {
			"prefix": ".depth",
			"body": ".depth()",
			"description": [
				"<TvmSlice>.depth() returns (uint64);",
				"Returns the depth of the slice. If slice has no references, then 0 is returned, otherwise function result is one plus the maximum of depths of the cells referred to from the slice."
			]
		},
		"<TvmSlice>.hasNBits": {
			"prefix": ".hasNBits",
			"body": ".hasNBits(${uint16 bits}))",
			"description": [
				"<TvmSlice>.hasNBits(uint16 bits) returns (bool);",
				"Checks whether the slice contains the specified amount of data bits."
			]
		},
		"<TvmSlice>.hasNRefs": {
			"prefix": ".hasNRefs",
			"body": ".hasNRefs(${uint8 bits}))",
			"description": [
				"<TvmSlice>.hasNRefs(uint8 bits) returns (bool);",
				"Checks whether the slice contains the specified amount of references."
			]
		},
		"<TvmSlice>.hasNBitsAndRefs": {
			"prefix": ".hasNBitsAndRefs",
			"body": ".hasNBitsAndRefs(${uint16 bits}, ${uint8 refs})",
			"description": [
				"<TvmSlice>.hasNBitsAndRefs(uint16 bits, uint8 refs) returns (bool);",
				"Checks whether the slice contains the specified amount of data bits and references."
			]
		},
		"<TvmSlice>.compare": {
			"prefix": ".compare",
			"body": ".compare(${1:TvmSlice other})",
			"description": [
				"<TvmSlice>.compare(TvmSlice other) returns (int8);",
				"Lexicographically compares the slice and other data bits of the root slice and returns result as an integer:",
				"1 - slice > other",
				"0 - slice == other",
				"-1 - slice < other"
			]
		},
		"<TvmSlice>.decode": {
			"prefix": ".decode",
			"body": ".decode(${1:TypeA}, ${2:TypeB} ...)",
			"description": [
				"<TvmSlice>.decode(TypeA, TypeB, ...) returns (TypeA /*a*/, TypeB /*b*/, ...);",
				"Supported types: uintN, intN, bytesN, bool, ufixedMxN, fixedMxN, address, contract, TvmCell, bytes, string, mapping, ExtraCurrencyCollection, array, optional and struct",
				"Example:",
				"TvmSlice slice = ...;",
				"(uint8 a, uint16 b) = slice.decode(uint8, uint16);",
				"(uint16 num0, uint32 num1, address addr) = slice.decode(uint16, uint32, address);"
			]
		},
		"<TvmSlice>.loadRef": {
			"prefix": ".loadRef",
			"body": ".loadRef()",
			"description": [
				"<TvmSlice>.loadRef() returns (TvmCell);",
				"Loads a cell from the slice reference."				
			]
		},
		"<TvmSlice>.loadRefAsSlice": {
			"prefix": ".loadRefAsSlice",
			"body": ".loadRefAsSlice()",
			"description": [
				"<TvmSlice>.loadRefAsSlice() returns (TvmSlice);",
				"Loads a cell from the slice reference and converts it into a slice."				
			]
		},
		"<TvmSlice>.loadSigned": {
			"prefix": ".loadSigned",
			"body": ".loadSigned(${1:uint16 bitSize})",
			"description": [
				"<TvmSlice>.loadSigned(uint16 bitSize) returns (int);",
				"Loads a signed integer with the given bitSize from the slice."				
			]
		},
		"<TvmSlice>.loadUnsigned": {
			"prefix": ".loadSiloadUnsignedgned",
			"body": ".loadUnsigned(${1:uint16 bitSize})",
			"description": [
				"<TvmSlice>.loadSigned(uint16 bitSize) returns (uint);",
				"Loads an unsigned integer with the given bitSize from the slice."				
			]
		},
		"<TvmSlice>.loadTons": {
			"prefix": ".loadTons",
			"body": ".loadTons()",
			"description": [
				"<TvmSlice>.loadTons() returns (uint128);",
				"Loads (deserializes) VarUInteger 16 and returns an unsigned 128-bit integer."				
			]
		},
		"<TvmSlice>.loadSlice": {
			"prefix": ".loadSlice",
			"body": ".loadSlice()",
			"description": [
				"<TvmSlice>.loadSlice(uint length) returns (TvmSlice);",
				"<TvmSlice>.loadSlice(uint length, uint refs) returns (TvmSlice);",				
				"Loads the first length bits and refs references from the slice into a separate slice."				
			]
		},
		"<TvmSlice>.decodeFunctionParams": {
			"prefix": ".decodeFunctionParams",
			"body": ".decodeFunctionParams(${1:functionName})",
			"description": [
				"Decodes parameters of the function or constructor (if contract type is provided). This function is usually used in onBounce function.",
				"Examples:",
				"Decode parameters of the public function which doesn't return values:",
				"<TvmSlice>.decodeFunctionParams(functionName) returns (TypeA /*a*/, TypeB /*b*/, ...);",
				"Decode parameters of the public function which returns values:",
				"<TvmSlice>.decodeFunctionParams(functionName) returns (uint32 callbackFunctionId, TypeA /*a*/, TypeB /*b*/, ...);",
				"Decode constructor parameters:",				
				"<TvmSlice>.decodeFunctionParams(ContractName) returns (TypeA /*a*/, TypeB /*b*/, ...);"				
			]
		},
		"<TvmSlice>.skip": {
			"prefix": ".skip",
			"body": ".skip(${1:uint length}${0: ,uint refs})",
			"description": [
				"<TvmSlice>.skip(uint length);",
				"<TvmSlice>.skip(uint length, uint refs);",				
				"Skips the first length bits and refs references from the slice."				
			]
		},
		"<TvmBuilder>.toSlice": {
			"prefix": ".toSlice",
			"body": ".toSlice()",
			"description": [
				"<TvmBuilder>.toSlice() returns (TvmSlice);",
				"Converts the builder into a slice."								
			]
		},
		"<TvmBuilder>.toCell": {
			"prefix": ".toCell",
			"body": ".toCell()",
			"description": [
				"<TvmBuilder>.toCell() returns (TvmCell);",
				"Converts the builder into a cell."								
			]
		},
		"<TvmBuilder>.bits": {
			"prefix": ".bits",
			"body": ".bits()",
			"description": [
				"<TvmBuilder>.bits() returns (uint16);",
				"Returns the number of data bits already stored in the builder."								
			]
		},
		"<TvmBuilder>.refs": {
			"prefix": ".refs",
			"body": ".refs()",
			"description": [
				"<TvmBuilder>.refs() returns (uint8);",
				"Returns the number of references already stored in the builder."								
			]
		},
		"<TvmBuilder>.bitsAndRefs": {
			"prefix": ".bitsAndRefs",
			"body": ".bitsAndRefs()",
			"description": [
				"<TvmBuilder>.bitsAndRefs() returns (uint16 /*bits*/, uint8 /*refs*/);",
				"Returns the number of data bits and references already stored in the builder."								
			]
		},
		"<TvmBuilder>.remBits": {
			"prefix": ".remBits",
			"body": ".remBits()",
			"description": [
				"<TvmBuilder>.remBits() returns (uint16);",
				"Returns the number of data bits that can still be stored in the builder."								
			]
		},
		"<TvmBuilder>.remRefs": {
			"prefix": ".remRefs",
			"body": ".remRefs()",
			"description": [
				"<TvmBuilder>.remRefs() returns (uint8);",
				"Returns the number of references that can still be stored in the builder."								
			]
		},
		"<TvmBuilder>.remBitsAndRefs": {
			"prefix": ".remBitsAndRefs",
			"body": ".remBitsAndRefs()",
			"description": [
				"<TvmBuilder>.remBitsAndRefs() returns (uint16 /*bits*/, uint8 /*refs*/);",
				"Returns the number of data bits and references that can still be stored in the builder."								
			]
		},
		"<TvmBuilder>.depth": {
			"prefix": ".depth",
			"body": ".depth()",
			"description": [
				"<TvmBuilder>.depth() returns (uint64);",
				"Returns the depth of the builder. If no cell references are stored in the builder, then 0 is returned; otherwise function result is one plus the maximum of depths of cells referred to from the builder."								
			]
		},
		"<TvmBuilder>.store": {
			"prefix": ".store",
			"body": ".store(${list_of_values})",
			"description": [
				"<TvmBuilder>.store(/*list_of_values*/);",
				"Stores the list of values in the builder.",
				"Example:",							
				"uint8 a = 11;",
				"int16 b = 22;",
				"TvmBuilder builder;",
				"builder.store(a, b, uint(33));"			
			]
		},
		"<TvmBuilder>.storeOnes": {
			"prefix": ".storeOnes",
			"body": ".storeOnes(${1:uint n})",
			"description": [
				"<TvmBuilder>.storeOnes(uint n);",
				"Stores n binary ones into Builder."								
			]
		},
		"<TvmBuilder>.storeZeroes": {
			"prefix": ".storeZeroes",
			"body": ".storeZeroes(${1:uint n})",
			"description": [
				"<TvmBuilder>.storeZeroes(uint n);",
				"Stores n binary zeroes into Builder."
			]
		},
		"<TvmBuilder>.storeSigned": {
			"prefix": ".storeSigned",
			"body": ".storeSigned(${1:int256 value}, ${2:uint16 bitSize})",
			"description": [
				"<TvmBuilder>.storeSigned(int256 value, uint16 bitSize);",
				"Stores a signed integer value with given bitSize in the builder."
			]
		},
		"<TvmBuilder>.storeUnsigned": {
			"prefix": ".storeUnsigned",
			"body": ".storeUnsigned(${1:uint256 value}, ${2:uint16 bitSize})",
			"description": [
				"<TvmBuilder>.storeUnsigned(uint256 value, uint16 bitSize);",
				"Stores an unsigned integer value with given bitSize in the builder."
			]
		},
		"<TvmBuilder>.storeRef": {
			"prefix": ".storeRef",
			"body": ".storeRef(${1|TvmBuilder b,TvmCell c,TvmSlice s|})",
			"description": [
			"<TvmBuilder>.storeRef(TvmBuilder b);",
			"<TvmBuilder>.storeRef(TvmCell c);",
			"<TvmBuilder>.storeRef(TvmSlice s);",
			"Stores TvmBuilder b/TvmCell c/TvmSlice c in the reference of the builder."				
			]
		},
		"<TvmBuilder>.storeTons": {
			"prefix": ".storeTons",
			"body": ".storeTons(${1:uint128 value}})",
			"description": [
				"<TvmBuilder>.storeTons(uint128 value);",
				"Stores (serializes) an integer value and stores it in the builder as VarUInteger 16. See TL-B scheme."
			]
		},
		"<optional(Type)>.get": {
			"prefix": ".get",
			"body": ".get()",
			"description": [
				"<optional(Type)>.get() returns (Type);",
				"Returns the contained value, if the optional contains one. Otherwise, throws an exception."
			]
		},
		"<optional(Type)>.hasValue": {
			"prefix": ".hasValue",
			"body": ".hasValue()",
			"description": [
				"<optional(Type)>.hasValue() returns (bool);",
				"Checks whether opt contains a value."
			]
		},
		"<optional(Type)>.set": {
			"prefix": ".set",
			"body": ".set(${1:Type value})",
			"description": [
				"<optional(Type)>.set(Type value);",
				"Replaces the content of the optional with the contents of other."
			]
		},
		"<optional(Type)>.reset": {
			"prefix": ".reset",
			"body": ".reset()",
			"description": [
				"<optional(Type)>.reset();",
				"Deletes the content of the optional."
			]
		},
		"<vector(Type)>.push": {
			"prefix": ".push",
			"body": ".push(${1:Type obj})",
			"description": [
				"<vector(Type)>.push(Type obj);",
				"Appends obj to the vector.\n",
				"Example:",
				"vector(uint) vect;",
				"uint a = 11;",
				"vect.push(a);",
				"vect.push(111);"
			]
		},
		"<vector(Type)>.pop": {
			"prefix": ".pop",
			"body": ".pop()",
			"description": [
				"<vector(Type)>.pop() returns (Type);",
				"Pops the last value from the vector and returns is.\n",
				"Example:",
				"vector(uint) vect;",
				"...",
				"uint a = vect.pop();"				
			]
		},
		"<vector(Type)>.length": {
			"prefix": ".length",
			"body": ".length()",
			"description": [
				"<vector(Type)>.length() returns (uint8);",
				"Returns length of the vector.\n",
				"Example:",
				"vector(uint) vect;",
				"...",
				"uint8 len = vect.length();"			
			]
		},
		"<vector(Type)>.empty": {
			"prefix": ".empty",
			"body": ".empty()",
			"description": [
				"<vector(Type)>.empty() returns (bool);",
				"Checks whether the vector is empty.\n",
				"Example:",
				"vector(uint) vect;",
				"...",
				"bool is_empty = vect.empty();"			
			]
		},
        "for range": {
			"prefix": "for_range",
			"body": "for ((uint ${1:key}, uint ${2:value}) : ${3:range_expression}) {\n\t$0\n}",
			"description": [
				"Executes a for loop over a range.\n",
				"Examples:",
				"for (uint val : arr) {}// iteration over array ",
				"for ((uint32 key, uint value) : map) {} // iteration over mapping ",
				"for ((, uint value) : map) {} // key is omitted  "
			]
		},
        "repeat": {
			"prefix": "repeat",
			"body": "repeat(${1:uint n}) {\n\t$0\n}",
			"description": "Allows repeating block of code several times. A repeat loop evaluates the expression only one time. This expression must have an unsigned integer type."							
		},
        "bitSize": {
			"prefix": "bitSize",
			"body": "bitSize(${1:int x})",
			"description": [
				"bitSize(int x) returns (uint16)",
				"bitSize computes the smallest c ≥ 0 such that x fits into a c-bit signed integer (−2c−1 ≤ x < 2c−1).\n",
				"Example:",
				"require(bitSize(12) == 5); // 12 == 1100(in bin sys)",
				"require(bitSize(1) == 2);",
				"require(bitSize(-1) == 1);",
				"require(bitSize(0) == 0);"							
			]
		},
        "uBitSize": {
			"prefix": "uBitSize",
			"body": "uBitSize(${1:uint x})",
			"description": [
				"uBitSize(int x) returns (uint16)",
				"uBitSize computes the smallest c ≥ 0 such that x fits into a c-bit unsigned integer (0 ≤ x < 2c).",
				"Example:\n",
				"require(uBitSize(10) == 4);",
				"require(uBitSize(1) == 1);",
				"require(uBitSize(0) == 0);"							
			]
		},
        "<struct>.unpack": {
			"prefix": ".unpack",
			"body": ".unpack()",
			"description": [
				"<struct>.unpack() returns (TypeA /*a*/, TypeB /*b*/, ...);",
				"Unpacks all members stored in the struct.",
				"Example:\n",
				"struct MyStruct {\n\tuint a;\n\tint b;\n\taddress c;\n}\n",
				"function f() pure public {\n\tMyStruct s = MyStruct(1, -1, address(2));\n\t(uint a, int b, address c) = s.unpack();\n}"							
			]
		},
        "<array>.empty": {
			"prefix": ".empty",
			"body": ".empty()",
			"description": [
				"<array>.empty() returns (bool);",
				"Returns status flag whether the array is empty (its length is 0).",
				"Example:\n",
				"uint[] arr;\nrequire(arr.empty());\narr.push();\nrequire(!arr.empty());"							
			]
		},
        "<bytes>.empty": {
			"prefix": ".empty",
			"body": ".empty()",
			"description": [
				"<bytes>.empty() returns (bool);\n",
				"Returns status flag whether the bytes is empty (its length is 0)."				
			]
		},
        "<bytes>.length": {
			"prefix": ".length",
			"body": ".length",
			"description": [
				"<bytes>.length returns (uint)\n",
				"Returns length of the byte array."			
			]
		},
        "<bytes>.toSlice": {
			"prefix": ".toSlice",
			"body": ".toSlice()",
			"description": [
				"<bytes>.toSlice() returns (TvmSlice);\n",
				"Converts bytes to TvmSlice.",
				"Warning: if length of the array is greater than 127\nthen extra bytes are stored in the first reference of the slice. \nUse <TvmSlice>.loadRef() to load that extra bytes."			
			]
		},
        "<bytes>.dataSize": {
			"prefix": ".dataSize",
			"body": ".dataSize(${1:uint n})",
			"description": "<bytes>.dataSize(uint n) returns (uint /*cells*/, uint /*bits*/, uint /*refs*/);"							
		},
        "<bytes>.dataSizeQ": {
			"prefix": ".dataSizeQ",
			"body": ".dataSizeQ(${1:uint n})",
			"description": "<bytes>.dataSizeQ(uint n) \nreturns (optional(uint /*cells*/, uint /*bits*/, uint /*refs*/));"							
		},
        "<bytes>.append": {
			"prefix": ".append",
			"body": ".append(${1:bytes tail})",
			"description": [
				"<bytes>.append(bytes tail);\n",
				"Modifies the bytes by concatenating tail bytes to the end of the bytes."							
			]
		},
        "<string>.empty": {
			"prefix": ".empty",
			"body": ".empty()",
			"description": [
				"<string>.empty() returns (bool);\n",
				"Returns status flag whether the string is empty (its length is 0)."							
			]
		},
        "<string>.byteLength": {
			"prefix": ".byteLength",
			"body": ".byteLength()",
			"description": [
				"<string>.byteLength() returns (uint32);\n",
				"Returns byte length of the string data."							
			]
		},
        "<string>.substr": {
			"prefix": ".substr",
			"body": ".substr()",
			"description": [
				"<string>.substr(uint from[, uint count]) returns (string);\n",
				"Returns a substring starting from the\nbyte with number from with byte length count.\nNote: if count is not set, then the new string \nwill be cut from the from byte to the end of the string.",
				"Example:",
				"string long = \"0123456789\";\nstring a = long.substr(1, 2); // a = \"12\"\nstring b = long.substr(6); // b = \"6789\""
			]
		},
        "<string>.append": {
			"prefix": ".append",
			"body": ".append(${1:string tail})",
			"description": [
				"<string>.append(string tail);\n",
				"Appends the tail string to the string."				
			]
		},
        "<string>.find": {
			"prefix": ".find",
			"body": ".find(${1|substring,byte('symbol')|})",
			"description": [
				"<string>.find(bytes1 symbol) returns (optional(uint32));\n",
				"<string>.find(string substr) returns (optional(uint32));\n",
				"Looks for symbol (or substring) in the string \nand returns index of the first (find) occurrence. \nIf there is no such symbol in the string, \nempty optional is returned."				
			]
		},
        "<string>.findLast": {
			"prefix": ".findLast",
			"body": ".findLast(${1|substring,byte('symbol')|})",
			"description": [
				"<string>.findLast(bytes1 symbol) returns (optional(uint32));\n",
				"<string>.findLast(string substr) returns (optional(uint32));\n",
				"Looks for symbol (or substring) in the string and returns index of the last (findLast) occurrence. If there is no such symbol in the string, empty optional is returned."				
			]
		},
        "format": {
			"prefix": "format",
			"body": "format(${1: string template}, ${2:TypeA a, TypeB b, ...})",
			"description": [
				"format(string template, TypeA a, TypeB b, ...) returns (string);\n",
				"Builds a string with arbitrary parameters.",
				"Example:",
				"format(\"Hello {}\", 123) \\\\ \"Hello 123\"\n"				
			]
		},
        "stoi": {
			"prefix": "stoi",
			"body": "stoi(${1: string inputStr})",
			"description": [
				"stoi(string inputStr) returns (uint /*result*/, bool /*status*/);\n",
				"Converts a string into an integer. \nString is meant to be number in decimal format,\nonly if string starts with '0x' \nit will be converted from a hexadecimal format.\nFunction returns the integer, that can\nbe converted from uint to int and boolean status,\nwhich is false in case of illegal characters\nin the string.\nWarning: this function consumes too much gas,\nthat's why it's better not to use it onchain. ",
				"Example:",
				"(res, status) = stoi(\"123\");"				
			]
		},
        "address": {
			"prefix": "address",
			"body": "address(${1: address_value})",
			"description": [
				"Constructs an address of type addr_std with\nzero workchain id and given address value.\n",				
				"Example:",
				"uint address_value;\naddress addrStd = address(address_value);"				
			]
		},
        "address.makeAddrStd": {
			"prefix": "address.makeAddrStd",
			"body": "address.makeAddrStd(${1: workchainId}, ${2: address})",
			"description": "Constructs an address of type addr_std\nwith given workchain id wid and value address_value.\n"
		},
        "address.makeAddrNone": {
			"prefix": "address.makeAddrNone",
			"body": "address.makeAddrNone()",
			"description": "Constructs an address of type addr_none.\n"
		},
        "address.makeAddrExtern": {
			"prefix": "address.makeAddrExtern",
			"body": "address.makeAddrExtern(${1: addrNumber}, ${2: bitCnt})",
			"description": "Constructs an address of type addr_extern \nwith given value with bitCnt bit length.\n"
		},
        "<address>.wid": {
			"prefix": ".wid",
			"body": ".wid()",
			"description": [
				"<address>.wid returns (int8);\n",
				"Returns the workchain id of addr_std or addr_var.\nThrows \"range check error\" exception \n(error code equal to 5) for another address types."
			]
		},
        "<address>.value": {
			"prefix": ".value",
			"body": ".value()",
			"description": [
				"<address>.value returns (uint);\n",
				"Returns the address value of addr_std \nor addr_var if addr_var has 256-bit\naddress value. \nThrows \"range check error\" exception (error code equal to 5) \nfor another address types.\n"
			]
		},
        "<address>.balance": {
			"prefix": "address(this).balance",
			"body": "address(this).balance",
			"description": [
				"address(this).balance returns (uint128);\n",
				"Returns the balance of this contract in nanotons.\n"
			]
		},
        "<address>.currencies": {
			"prefix": "address(this).currencies",
			"body": "address(this).currencies",
			"description": [
				"address(this).currencies returns (ExtraCurrencyCollection);\n",
				"Returns currencies on the balance of this contract.\n"
			]
		},
        "<address>.getType": {
			"prefix": ".getType",
			"body": ".getType()",
			"description": [
				"<address>.getType() returns (uint8);\n",
				"Returns type of the address:\n0 - addr_none 1 - addr_extern 2 - addr_std"
			]
		},
        "<address>.isStdZero": {
			"prefix": ".isStdZero",
			"body": ".isStdZero()",
			"description": [
				"<address>.isStdZero() returns (bool);\n",
				"Returns the result of comparison between this \naddress with zero address of type addr_std.\n"
			]
		},
        "<address>.isStdAddrWithoutAnyCast": {
			"prefix": ".isStdAddrWithoutAnyCast",
			"body": ".isStdAddrWithoutAnyCast()",
			"description": [
				"<address>.isStdAddrWithoutAnyCast() returns (bool);\n",
				"Check whether this address is of type addr_std without any cast.\n"
			]
		},
        "<address>.isExternZero": {
			"prefix": ".isExternZero",
			"body": ".isExternZero()",
			"description": [
				"<address>.isExternZero() returns (bool);\n",
				"Returns the result of comparison between this address \nwith zero address of type addr_extern.\n"
			]
		},
        "<address>.isNone": {
			"prefix": ".isNone",
			"body": ".isNone()",
			"description": [
				"<address>.isNone() returns (bool);\n",
				"Check whether this address is of type addr_none.\n"
			]
		},
        "<address>.unpack": {
			"prefix": ".unpack",
			"body": ".unpack()",
			"description": [
				"<address>.unpack() returns (int8 /*wid*/, uint256 /*value*/);\n",
				"Parses <address> containing a valid MsgAddressInt \n(addr_std or addr_var), applies rewriting \nfrom the anycast (if present) to the same-length \nprefix of the address, and returns both \nthe workchain wid and the 256-bit address \nvalue. If the address value is not 256-bit, \nor if <address> is not a valid serialization \nof MsgAddressInt, throws a cell deserialization \nexception.",
				"It's wrapper for opcode REWRITESTDADDR.\n",
				"Example:",
				"(int8 wid, uint addr) = address(this).unpack();\n"
			]
		},
        "<address>.transfer": {
			"prefix": ".transfer",
			"body": ".transfer(${1:uint128 value}, ${2:bool bounce}, ${3:uint16 flag}, ${4:TvmCell body}, ${5:ExtraCurrencyCollection currencies})",
			"description": [
				"<address>.transfer(\n\tuint128 value, \n\tbool bounce, \n\tuint16 flag, \n\tTvmCell body, \n\tExtraCurrencyCollection currencies\n);\n",
				"Sends an internal outbound message to defined address.\nAll parameters can be omitted, except value.\n"				
			]
		},
        "<mapping>.min": {
			"prefix": ".min",
			"body": ".min()",
			"description": [
				"<map>.min() returns (optional(KeyType, ValueType));\n",
				"Computes the minimal key in the mapping and \nreturns an optional value containing \nthat key and the associated value. \nIf mapping is empty, this function returns \nan empty optional.\n"				
			]
		},
        "<mapping>.max": {
			"prefix": ".max",
			"body": ".max()",
			"description": [
				"<map>.max() returns (optional(KeyType, ValueType));\n",
				"Computes the maximal key in the mapping and \nreturns an optional value containing \nthat key and the associated value. \nIf mapping is empty, this function returns \nan empty optional.\n"				
			]
		},
        "<mapping>.next": {
			"prefix": ".next",
			"body": ".next(${1:KeyType key})",
			"description": [
				"<map>.next(KeyType key) returns (optional(KeyType, ValueType));\n",
				"Computes the maximal key in the mapping \nthat is lexicographically greater \nthan key and returns an optional value \ncontaining that key and the associated value. \nReturns an empty optional if there is no \nsuch key. \nIf KeyType is an integer type, argument for \nthis functions can not possibly fit KeyType.\n",
				"Example:",
				"mapping(uint8 => uint) m;\noptional(uint8, uint) = m.next(-1);"				
			]
		},
        "<mapping>.prev": {
			"prefix": ".prev",
			"body": ".prev(${1:KeyType key})",
			"description": [
				"<map>.prev(KeyType key) returns (optional(KeyType, ValueType));\n",
				"Computes the minimal key in the mapping \nthat is lexicographically less \nthan key and returns an optional value \ncontaining that key and the associated value. \nReturns an empty optional if there is no \nsuch key. \nIf KeyType is an integer type, argument for \nthis functions can not possibly fit KeyType.\n",				
				"Example:",
				"mapping(uint8 => uint) m;\noptional(uint8, uint) = m.prev(123);"
			]
		},
        "<mapping>.nextOrEq": {
			"prefix": ".nextOrEq",
			"body": ".nextOrEq(${1:KeyType key})",
			"description": [
				"<map>.nextOrEq(KeyType key) returns (optional(KeyType, ValueType));\n",
				"Computes the maximal key in the mapping that \nis lexicographically greater than or equal \nto key and returns an optional value \ncontaining that key and the associated value. \nReturns an empty optional if there \nis no such key. \nIf KeyType is an integer type, argument \nfor this functions can not possibly fit KeyType.\n"						
			]
		},
        "<mapping>.prevOrEq": {
			"prefix": ".prevOrEq",
			"body": ".prevOrEq(${1:KeyType key})",
			"description": [
				"<map>.prevOrEq(KeyType key) returns (optional(KeyType, ValueType));\n",
				"Computes the minimal key in the mapping that \nis lexicographically less than or equal \nto key and returns an optional value \ncontaining that key and the associated value. \nReturns an empty optional if there \nis no such key. \nIf KeyType is an integer type, argument \nfor this functions can not possibly fit KeyType.\n"						
			]
		},
        "<mapping>.delMin": {
			"prefix": ".delMin",
			"body": ".delMin()",
			"description": [
				"<map>.delMin() returns (optional(KeyType, ValueType));\n",
				"If mapping is not empty then this function computes \nthe minimal key of the mapping, deletes that key \nand the associated value from the mapping and \nreturns an optional value containing that key and \nthe associated value. \nReturns an empty optional if there is no such key.\n"
			]
		},
        "<mapping>.delMax": {
			"prefix": ".delMax",
			"body": ".delMax()",
			"description": [
				"<map>.delMax() returns (optional(KeyType, ValueType));\n",
				"If mapping is not empty then this function computes \nthe maximum key of the mapping, deletes that key \nand the associated value from the mapping and \nreturns an optional value containing that key and \nthe associated value. \nReturns an empty optional if there is no such key.\n"
			]
		},
        "<mapping>.fetch": {
			"prefix": ".fetch",
			"body": ".fetch(${1:KeyType key})",
			"description": [
				"<map>.fetch(KeyType key) returns (optional(ValueType));\n",
				"Checks whether key presents in the mapping \nand returns an optional with the associated value. \nReturns an empty optional if there is no \nsuch key.\n"
			]
		},
        "<mapping>.exists": {
			"prefix": ".exists",
			"body": ".exists(${1:KeyType key})",
			"description": [
				"<map>.exists(KeyType key) returns (bool);\n",
				"Returns a status flag whether key presents in the mapping.\n"
			]
		},
        "<mapping>.empty": {
			"prefix": ".empty",
			"body": ".empty()",
			"description": [
				"<map>.empty() returns (bool);\n",
				"Returns a status flag whether the mapping is empty.\n"
			]
		},
        "<mapping>.replace": {
			"prefix": ".replace",
			"body": ".replace(${1:KeyType key}, ${2:ValueType value})",
			"description": [
				"<map>.replace(KeyType key, ValueType value) returns (bool);\n",
				"Sets the value associated with key only if \nkey presents in the mapping and returns the success flag.\n"
			]
		},
        "<mapping>.add": {
			"prefix": ".add",
			"body": ".add(${1:KeyType key}, ${2:ValueType value})",
			"description": [
				"<map>.add(KeyType key, ValueType value) returns (bool);\n",
				"Sets the value associated with key only if key does not present in the mapping.\n"
			]
		},
        "<mapping>.getSet": {
			"prefix": ".getSet",
			"body": ".getSet(${1:KeyType key}, ${2:ValueType value})",
			"description": [
				"<map>.getSet(KeyType key, ValueType value) returns (optional(ValueType));\n",
				"Sets the value associated with key, \nbut also returns an optional with \nthe old value associated with the key, \nif presents. \nOtherwise, returns an empty optional.\n"
			]
		},
        "<mapping>.getAdd": {
			"prefix": ".getAdd",
			"body": ".getAdd(${1:KeyType key}, ${2:ValueType value})",
			"description": [
				"<map>.getAdd(KeyType key, ValueType value) returns (optional(ValueType));\n",
				"Sets the value associated with key, \nbut only if key does not present in \nthe mapping. \nReturns an optional with the old value \nwithout changing the dictionary if that \nvalue presents in the mapping, otherwise \nreturns an empty optional.\n"
			]
		},
        "<mapping>.getReplace": {
			"prefix": ".getReplace",
			"body": ".getReplace(${1:KeyType key}, ${2:ValueType value})",
			"description": [
				"<map>.getReplace(KeyType key, ValueType value) returns (optional(ValueType));\n",
				"Sets the value associated with key, \nbut only if key presents in the mapping. \nOn success, returns an optional with \nthe old value associated with the key. \nOtherwise, returns an empty optional.\n"
			]
		},
        "require": {
			"prefix": "require",
			"body": "require(${1:bool condition}, ${2:uint errorCode}, ${3:Type exceptionArgument})",
			"description": [
				"require(bool condition, [uint errorCode = 100, [Type exceptionArgument]]);\n",
				"require function can be used to check \nthe condition and throw an exception if the \ncondition is not met. \nThe function takes condition and optional parameters: \nerror code (unsigned integer) and \nthe object of any type.\n",
				"Example:",
				"uint a = 5;\nrequire(a == 6, 101, \"a is not equal to six\");"
			]
		},
        "revert": {
			"prefix": "revert",
			"body": "revert(${1:uint errorCode}, ${2:Type exceptionArgument})",
			"description": [
				"revert(uint errorCode = 100, [Type exceptionArgument]);\n",
				"revert function can be used to throw exceptions. \nThe function takes an optional error code \n(unsigned integer) and the object of any type.\n",
				"Example:",
				"revert(102, \"We have a some problem\");"
			]
		},
        "receive": {
			"prefix": "receive",
			"body": "receive () external {\n\t$0\n}",
			"description": "receive function is called in 2 cases:\n\t1. msg.data (or message body) is empty.\n\t2. msg.data starts with 32-bit zero.\n\tThen message body may contain data, \n\tfor example string with comment."
		},
        "fallback": {
			"prefix": "fallback",
			"body": "fallback () external {\n\t$0\n}",
			"description": "fallback function is called when a body of an inbound \ninternal/external message in such cases:\n\t1. The message contains a function id that the contract \n\tdoesn't contain.\n\t2. Bit length of message between 1 and 31 (including).\n\t3. Bit length of message equals to zero, but the \n\tmessage contains reference(s).\n"
		},
        "onBounce": {
			"prefix": "onBounce",
			"body": "onBounce (TvmSlice body) external {\n\t$0\n}",
			"description": "onBounce function is executed when contract \nreceives a bounced inbound internal message. \nThe message is generated by the network if \nthe contract sends an internal message with bounce: true and\n\tcalled contract doesn't exist;\n\tcalled contract fails at storage/credit/computing \n\tphase (not at action phase!).\n"
		},
        "onTickTock": {
			"prefix": "onTickTock",
			"body": "onTickTock (TvmSlice isTock) external {\n\t$0\n}",
			"description": "onTickTock function is executed on tick/tock \ntransaction. That transactions are automatically invoked for \ncertain special accounts. \nFor tick transactions isTock is false, \nfor tock transactions - true.\n"
		},
        "onCodeUpgrade": {
			"prefix": "onCodeUpgrade",
			"body": "onCodeUpgrade () private {\n\t$0\n}",
			"description": "onCodeUpgrade function can have arbitrary set of \narguments and should be executed after \ntvm.setcode() function call. \nIn this function tvm.resetStorage() should be \ncalled if the set of state variables is changed \nin the new version of the contract. \nThis function implicitly calls tvm.commit(). \nThen return from onCodeUpgrade TVM execution is \nfinished with exit code 0.\n"
		},
        "afterSignatureCheck": {
			"prefix": "afterSignatureCheck",
			"body": "afterSignatureCheck (TvmSlice body, TvmCell message) private inline returns (TvmSlice){\n\t$0\n}",
			"description": "afterSignatureCheck function is used to define \ncustom replay protection function instead of the \ndefault one. \nNever call tvm.commit() or tvm.accept() in the \nfunction because the function can be called \nbefore calling constructor.\n"
		},
        "msg.sender": {
			"prefix": "msg.sender",
			"body": "msg.sender",
			"description": [
				"msg.sender returns (address);\n",
				"Returns:\n\t* sender of the message for internal message.\n\t*address(0) for external message.\n\t*address(0) for tick/tock transaction."
			]
		},
        "msg.value": {
			"prefix": "msg.value",
			"body": "msg.value",
			"description": [
				"msg.value returns (uint128);\n",
				"Returns:\n\tBalance of the inbound message in nanotons for internal message.\n\t0 for external message.\n\tUndefined value for tick/tock transaction."
			]
		},
        "msg.currencies": {
			"prefix": "msg.currencies",
			"body": "msg.currencies",
			"description": [
				"msg.currencies returns (ExtraCurrencyCollection);\n",
				"Collections of arbitrary currencies contained \nin the balance of the inbound message."
			]
		},
        "msg.pubkey": {
			"prefix": "msg.pubkey",
			"body": "msg.pubkey()",
			"description": [
				"msg.pubkey() returns (uint256);\n",
				"Returns sender's public key, obtained from \nthe body of the external inbound message. \nIf the message is not signed, msg.pubkey() \nreturns 0. \nIf the message is signed and message header \n(pragma AbiHeader) does not contain pubkey \nthen msg.pubkey() is equal to tvm.pubkey()."
			]
		},
        "msg.isInternal": {
			"prefix": "msg.isInternal",
			"body": "msg.isInternal",
			"description": "Returns whether the contract is called by internal message."
		},
        "msg.isExternal": {
			"prefix": "msg.isExternal",
			"body": "msg.isExternal",
			"description": "Returns whether the contract is called by external message."
		},
        "msg.isTickTock": {
			"prefix": "msg.isTickTock",
			"body": "msg.isTickTock",
			"description": "Returns whether the contract is called by tick/tock transactions."
		},
        "msg.createdAt": {
			"prefix": "msg.createdAt",
			"body": "msg.createdAt",
			"description": [
				"msg.createdAt returns (uint32);\n",
				"Returns a field created_at of the external inbound message.\n"
			]
		},
        "msg.data": {
			"prefix": "msg.data",
			"body": "msg.data",
			"description": [
				"msg.data returns (TvmSlice);\n",
				"Returns a payload of the inbound message.\n"
			]
		},
        "tvm.accept": {
			"prefix": "tvm.accept",
			"body": "tvm.accept()",
			"description": [
				"tvm.accept();\n",
				"Executes TVM instruction \"ACCEPT\" (TVM - A.11.2. - F800). \nThis instruction sets current gas limit to its \nmaximal allowed value. \nThis action is required to process external messages, \nwhich bring no value.\n"
			]
		},
        "tvm.commit": {
			"prefix": "tvm.commit",
			"body": "tvm.commit()",
			"description": [
				"tvm.commit();\n",
				"Creates a \"check point\" of the state variables \n(by copying them from c7 to c4) and register c5. \nIf the contract throws an exception at the \ncomputing phase then the state variables and \nregister c5 will roll back to the \"check point\", \nand the computing phase will be considered \n\"successful\". \nIf contract doesn't throw an exception, \nit has no effect.\n"
			]
		},
        "tvm.rawCommit": {
			"prefix": "tvm.rawCommit",
			"body": "tvm.rawCommit()",
			"description": [
				"tvm.rawCommit();\n",
				"Creates a \"check point\" of the state variables but \n doesn't copy the state variables from c7 to c4. \nIt's a wrapper for opcode COMMIT. See TVM.\n",
				"Note: Don't use tvm.rawCommit() after \ntvm.accept() in processing external \nmessages because you don't save from c7 to \nc4 the hidden state variable timestamp, \nwhich is used for replay protection.\n"
			]
		},
        "tvm.getData": {
			"prefix": "tvm.getData",
			"body": "tvm.getData()",
			"description": [
				"tvm.getData() returns (TvmCell);\n",
				"It's an experimental function.\n A dual of the tvm.setData() returning value of c4 register. \nGetting a raw storage cell is useful when \nupgrading a new version of contract that \nintroduces an altered data layout.\nManipulation with a raw storage cell requires \nan understanding of the way the compiler \nlayouts the data. Refer to the description of \ntvm.setData() below to get more details.\n",
				"Note: state variables and replay protection \ntimestamp stored in data cell have the same \nvalues that were before the transaction. \nSee tvm.commit() how to update register c4.\n"
			]
		},
        "tvm.setData": {
			"prefix": "tvm.setData",
			"body": "tvm.setData()",
			"description": [
				"tvm.setData() returns (TvmCell);\n",
				"It's an experimental function.\nSet cell data to register c4. Note, after \nreturning from a public function all state \nvariable from c7 will copy to c4 and \ntvm.setData will have no effect. \nExample of usage of such hint to set c4:\n",
				"TvmCell data = ...;\ntvm.setData(data); // set register c4\ntvm.rawCommit();   // save register c4 and c5\nrevert(200);       // throw the exception to terminate the transaction\n",
				"Be careful with the hidden state variable timestamp and think about possibility of replaying external messages.\n"
			]
		},
        "tvm.log": {
			"prefix": "tvm.log",
			"body": "tvm.log(${1:string log})",
			"description": [
				"tvm.log(string log);\n",
				"Dumps log string. This function is wrapper for TVM \ninstructions PRINTSTR (for constant literal \nstrings shorter than 16 symbols) and STRDUMP (for \nother strings). logtvm is an alias for tvm.log(string).\nNote: For long strings dumps only the first 127 symbols.\n",
				"Example:",
				"tvm.log(\"Hello,world!\");\n"
			]
		},
        "tvm.hexdump": {
			"prefix": "tvm.hexdump",
			"body": "tvm.hexdump(${1:T a})",
			"description": [
				"tvm.hexdump(T a);\n",
				"Dumps cell data or integer. \nNote that for cells this function dumps data \nonly from the first cell. \nT must be an integer type or TvmCell.\n",
				"Example:",
				"tvm.hexdump(123);\\\\Output: 7B\n"
			]
		},
        "tvm.bindump": {
			"prefix": "tvm.bindump",
			"body": "tvm.bindump(${1:T a})",
			"description": [
				"tvm.bindump(T a);\n",
				"Dumps cell data or integer. \nNote that for cells this function dumps data \nonly from the first cell. \nT must be an integer type or TvmCell.\n",
				"Example:",
				"tvm.bindump(123);\\\\Output: 1111011\n"
			]
		},
        "tvm.setcode": {
			"prefix": "tvm.setcode",
			"body": "tvm.setcode(TvmCell newCode);",
			"description": [
				"tvm.setcode(TvmCell newCode);\n",
				"This command creates an output action that \nwould change this smart contract code to that \ngiven by Cell newCode (this change will take effect \nonly after the successful termination of the current \nrun of the smart contract).\n"
			]
		},
        "tvm.rawConfigParam": {
			"prefix": "tvm.rawConfigParam",
			"body": "tvm.rawConfigParam(${1:uint8 paramNumber});",
			"description": [
				"tvm.rawConfigParam(uint8 paramNumber) returns (TvmCell cell, bool status);",
				"Executes TVM instruction \"CONFIGPARAM\". \nThis command returns the value of the global configuration \nparameter with integer index paramNumber. \nArgument should be an integer literal. Supported \nparamNumbers: 1, 15, 17, 34.\n"
			]
		},
        "tvm.rawReserve": {
			"prefix": "tvm.rawReserve",
			"body": "tvm.rawReserve(${1:uint value), ${2:uint8 flag});",
			"description": [
				"tvm.rawReserve(uint value, uint8 flag);\ntvm.rawReserve(uint value, ExtraCurrencyCollection currency, uint8 flag);\n",
				"Creates an output action which reserves \nreserve nanotons. It is roughly equivalent to create \nan outbound message carrying reserve nanotons to \noneself, so that the subsequent output actions would \nnot be able to spend more money than the \nremainder. It's a wrapper for opcodes \"RAWRESERVE\" \nand \"RAWRESERVEX\".\n"
			]
		},
        "tvm.hash": {
			"prefix": "tvm.hash",
			"body": "tvm.hash(${1|TvmCell cellTree,string data,bytes data,TvmSlice data|});",
			"description": [
				"tvm.hash(TvmCell cellTree) returns (uint256);\ntvm.hash(string data) returns (uint256);\ntvm.hash(bytes data) returns (uint256);\ntvm.hash(TvmSlice data) returns (uint256);\n",
				"Executes TVM instruction \"HASHCU\" or \"HASHSU\". \nIt computes the representation hash of a given \nargument and returns it as a 256-bit unsigned integer. \nFor string and bytes it computes hash of the tree \nof cells, which contains data, but not data itself. \nSee sha256 to count hash of data.\n"
			]
		},
        "tvm.checkSign": {
			"prefix": "tvm.checkSign",
			"body": "tvm.checkSign(${1|uint256 hash\\, uint256 SignHighPart\\, uint256 SignLowPart\\, uint256 pubkey,uint256 hash\\, TvmSlice signature\\, uint256 pubkey,TvmSlice data\\, TvmSlice signature\\, uint256 pubkey|});",
			"description": "returns (bool)\nExecutes TVM instruction \"CHKSIGNU\" for variants 1 and 2. \nThis command checks the Ed25519-signature of a hash using public key pubkey. \nSignature is represented by two uint256 SignHighPart and \nSignLowPart in the first variant and by a slice signature \nin the second variant. \nIn the third variant executes TVM instruction \n\"CHKSIGNS\". \nThis command checks Ed25519-signature of data using \npublic key pubkey. Signature is represented by a \nslice signature.\n"							
		},
        "tvm.insertPubkey": {
			"prefix": "tvm.insertPubkey",
			"body": "tvm.insertPubkey(${1:TvmCell stateInit}, ${2:uint256 pubkey})",
			"description": [
				"tvm.insertPubkey(TvmCell stateInit, uint256 pubkey) returns (TvmCell);\n",
				"Inserts a public key into stateInit data field. \nIf stateInit has wrong format then throws exception.\n"		
			]					
		},
        "tvm.buildStateInit": {
			"prefix": "tvm.buildStateInit",
			"body": "tvm.buildStateInit(${1|TvmCell code\\, TvmCell data, TvmCell code\\, TvmCell data\\, uint8 splitDepth,{code: TvmCell code\\, data: TvmCell data\\, splitDepth: uint8 splitDepth\\,pubkey: uint256 pubkey\\, contr: contract Contract\\, varInit: {VarName0: varValue0\\, ...}}|})",
			"description": [
				"returns (TvmCell stateInit)\n",
				"Generates a StateInit (TBLKCH - 3.1.7.) from code and data.\n"							
			]
		},
        "tvm.buildEmptyData": {
			"prefix": "tvm.buildEmptyData",
			"body": "tvm.buildEmptyData(${1:uint256 publicKey})",
			"description": [
				"tvm.buildEmptyData(uint256 publicKey) returns (TvmCell);\n",
				"Generates a persistent storage of the contract \nthat contains only public key. data can be used to \ngenerate StateInit (TBLKCH - 3.1.7.).\n"						
			]					
		},
        "tvm.deploy": {
			"prefix": "tvm.deploy",
			"body": "tvm.deploy(${1:TvmCell stateInit}, ${2:TvmCell payload}, ${3:uint128 value}, ${4:int8 wid})",
			"description": [
				"returns(address);\n",
				"Deploys a new contract and returns the address \nof the deployed contract. This function may \nbe useful if you want to write a universal \ncontract that can deploy any contract. \n"						
			]					
		},
        "tvm.code": {
			"prefix": "tvm.code",
			"body": "tvm.code()",
			"description": [
				"tvm.code() returns (TvmCell);\n",
				"Returns contract's code. \n"						
			]					
		},
        "tvm.codeSalt": {
			"prefix": "tvm.codeSalt",
			"body": "tvm.codeSalt(${1:TvmCell code})",
			"description": [
				"tvm.codeSalt(TvmCell code) returns (optional(TvmCell) optSalt);\n",
				"If code contains salt then optSalt contains one. \nOtherwise, optSalt doesn't contain any value. \n"						
			]					
		},
        "tvm.pubkey": {
			"prefix": "tvm.pubkey",
			"body": "tvm.pubkey()",
			"description": [
				"tvm.pubkey() returns (uint256);\n",
				"Returns contract's public key, stored in contract data. If key is not set, function returns 0. \n"						
			]					
		},
        "tvm.setPubkey": {
			"prefix": "tvm.setPubkey",
			"body": "tvm.setPubkey(${1:uint256 newPubkey})",
			"description": [
				"tvm.setPubkey(uint256 newPubkey);\n",
				"Set new contract's public key.  \n"						
			]					
		},
        "tvm.setCurrentCode": {
			"prefix": "tvm.setCurrentCode",
			"body": "tvm.setCurrentCode(${1:TvmCell newCode})",
			"description": [
				"tvm.setCurrentCode(TvmCell newCode);\n",
				"Changes this smart contract current code to \nthat given by Cell newCode. Unlike tvm.setcode() this \nfunction changes code of the smart contract only \nfor current TVM execution, but has no effect \nafter termination of the current run of the smart \ncontract. \n"						
			]					
		},
        "tvm.resetStorage": {
			"prefix": "tvm.resetStorage",
			"body": "tvm.resetStorage()",
			"description": "Resets all state variables to their default values.\n"					
		},
        "tvm.functionId": {
			"prefix": "tvm.functionId",
			"body": "tvm.functionId(${1:functionName})",
			"description": [
				"// id of public function\ntvm.functionId(functionName) returns (uint32);\n\n// id of public constructor\ntvm.functionId(ContractName) returns (uint32);\n",
				"Returns a function id (uint32) for \npublic/external function or constructor. \n"						
			]					
		},
        "tvm.encodeBody": {
			"prefix": "tvm.encodeBody",
			"body": "tvm.encodeBody(${1:function},${2:callbackFunction},${3: arg0, arg1, arg2, ...})",
			"description": [
				"tvm.encodeBody(function, arg0, arg1, arg2, ...) returns (TvmCell);\ntvm.encodeBody(function, callbackFunction, arg0, arg1, arg2, ...) returns (TvmCell);\n",
				"Constructs a function call message body that can \nbe used as the payload for <address>.transfer(). \nIf function is responsible then callbackFunction \nparameter must be set.\n"						
			]					
		},
        "tvm.exit": {
			"prefix": "tvm.exit",
			"body": "tvm.exit()",
			"description": [
				"tvm.exit();\n",
				"Function are used to save state variables \nand to quickly terminate execution of the \nsmart contract.\nExit code is equal to zero\n"						
			]					
		},
        "tvm.exit1": {
			"prefix": "tvm.exit1",
			"body": "tvm.exit1()",
			"description": [
				"tvm.exit1();\n",
				"Function are used to save state variables \nand to quickly terminate execution of the \nsmart contract.\nExit code is equal to one\n"						
			]					
		},
        "tvm.buildExtMsg": {
			"prefix": "tvm.buildExtMsg",
			"body": "tvm.buildExtMsg({\n\tdest: ${1:address},\n\ttime:${2:uint64},\n\texpire:${3:uint64},\n\tcall:{${4:functionIdentifier[, list_of_function_arguments]}},\n\tsign:${5:bool},\n\tpubkey:${6:optional(uint256)},\n\tabiVer:${7:uint8},\n\tcallbackId:${8:uint32},\n\tonErrorId:${9:uint32}, \n\tstateInit:${10:TvmCell},\n\tsignBoxHandle:${11:optional(uint32)}\n\t\\});",
			"description": [
				"returns (TvmCell);\n",
				"Function should be used only offchain and \nintended to be used only in debot contracts. Allows \ncreating an external inbound message, that calls \nthe func function of the contract on address \ndestination with specified function arguments.\n"									
			]
		},
        "tvm.buildIntMsg": {
			"prefix": "tvm.buildIntMsg",
			"body": "tvm.buildIntMsg({\n\tdest:${1:address},\n\tvalue:${2:uint128},\n\tcall:{${4:function, [callbackFunction, ] arg0, arg1, arg2, ...}},\n\tbounce:${5:bool},\n\tcurrencies:${6:ExtraCurrencyCollection}\n\t\\});",			
			"description": [
				"returns (TvmCell);\n",
				"Function should be used only offchain and \nintended to be used only in debot contracts. Allows \ncreating an external inbound message, that calls \nthe func function of the contract on address \ndestination with specified function arguments.\n"								
			]	
		},
        "tvm.sendrawmsg": {
			"prefix": "tvm.sendrawmsg",
			"body": "tvm.sendrawmsg(${1:TvmCell msg}, ${2:uint8 flag});",			
			"description": [
				"tvm.sendrawmsg(TvmCell msg, uint8 flag);\n",
				"Send the internal/external message msg with flag. \nIt's wrapper for opcode SENDRAWMSG (TVM - A.11.10). \nInternal message msg can be generated by tvm.buildIntMsg().\n"								
			]	
		},
        "math.min": {
			"prefix": "math.min",
			"body": "math.min(${1:T a, T b, ...});",			
			"description": [
				"math.min(T a, T b, ...) returns (T);\n",
				"Returns the minimal value of the passed arguments. \nT should be an integer or fixed point type\n"								
			]	
		},
        "math.max": {
			"prefix": "math.max",
			"body": "math.max(${1:T a, T b, ...});",			
			"description": [
				"math.max(T a, T b, ...) returns (T);\n",
				"Returns the maximal value of the passed arguments. \nT should be an integer or fixed point type\n"								
			]	
		},
        "math.minmax": {
			"prefix": "math.minmax",
			"body": "math.minmax(${1:T a, T b, ...});",			
			"description": [
				"math.minmax(T a, T b) returns (T /*min*/, T /*max*/);\n",
				"Returns minimal and maximal values of \nthe passed arguments. \nT should be an integer or fixed point type\n",
				"Example:",
				"(uint a, uint b) = math.minmax(20, 10); // (10, 20)"								
			]	
		},
        "math.abs": {
			"prefix": "math.abs",
			"body": "math.abs(${1|intM val,fixedMxN val|});",			
			"description": [
				"math.abs(intM val) returns (intM);\nmath.abs(fixedMxN val) returns (fixedMxN);\n",
				"Computes the absolute value of the given integer.\n"												
			]	
		},
        "math.modpow2": {
			"prefix": "math.modpow2",
			"body": "math.modpow2(${1:uint value}, ${2:uint power});",			
			"description": [
				"math.modpow2(uint value, uint power) returns (uint);\n",
				"Computes the value modulo 2^power. \nNote that power should be a constant integer.\n"												
			]	
		},
        "math.divc": {
			"prefix": "math.divc",
			"body": "math.divc(${1:T a}, ${2:T b});",			
			"description": [
				"math.divc(T a, T b) returns (T);\n",
				"Returns result of the division of two integers. \nT should be an integer or fixed point type.\nThe return value is rounded ceiling\n"												
			]	
		},
        "math.divr": {
			"prefix": "math.divr",
			"body": "math.divr(${1:T a}, ${2:T b});",			
			"description": [
				"math.divr(T a, T b) returns (T);\n",
				"Returns result of the division of two integers. \nT should be an integer or fixed point type.\nThe return value is rounded nearest\n"												
			]	
		},
        "math.muldiv": {
			"prefix": "math.muldiv",
			"body": "math.muldiv(${1:T a}, ${2:T b}, ${3:T c});",			
			"description": [
				"math.muldiv(T a, T b, T c) returns (T);\n",
				"Multiplies two values and then divides \nthe result by a third value. \nT is integer type. The return value \nis rounded(floor). \n"																
			]	
		},
        "math.muldivr": {
			"prefix": "math.muldivr",
			"body": "math.muldivr(${1:T a}, ${2:T b}, ${3:T c});",			
			"description": [
				"math.muldivr(T a, T b, T c) returns (T);\n",
				"Multiplies two values and then divides \nthe result by a third value. \nT is integer type. The return value \nis rounded(nearest). \n"												
			]	
		},
        "math.muldivc": {
			"prefix": "math.muldivc",
			"body": "math.muldivc(${1:T a}, ${2:T b}, ${3:T c});",			
			"description": [
				"math.muldivc(T a, T b, T c) returns (T);\n",
				"Multiplies two values and then divides \nthe result by a third value. \nT is integer type. The return value \nis rounded(ceiling). \n"												
			]	
		},
        "math.muldivmod": {
			"prefix": "math.muldivmod",
			"body": "math.muldivmod(${1:T a}, ${2:T b}, ${3:T c});",			
			"description": [
				"math.muldivmod(T a, T b, T c) (T /*result*/, T /*remainder*/);\n",
				"This instruction multiplies first two arguments, \ndivides the result by third argument and \nreturns the result and the remainder. \nIntermediate result is stored in the 514 bit buffer, \nand the final result is rounded to the floor.\n"												
			]	
		},
        "math.divmod": {
			"prefix": "math.divmod",
			"body": "math.divmod(${1:T a}, ${2:T b});",			
			"description": [
				"math.divmod(T a, T b) returns (T /*result*/, T /*remainder*/);\n",
				"This instruction divides the first number \nby the second one and returns the result\nand the remainder. Result is rounded to the floor. \nT is integer type.\n"												
			]	
		},
        "math.sign": {
			"prefix": "math.sign",
			"body": "math.sign(${1:int val});",			
			"description": [
				"math.sign(int val) returns (int8);\n",
				"Returns number in case of sign of the argument value val:\n\t-1 if val is negative;\n\t0 if val is zero;\n\t1 if val is positive.\n"												
			]	
		},
        "tx.timestamp": {
			"prefix": "tx.timestamp",
			"body": "tx.timestamp",			
			"description": [
				"tx.timestamp returns (uint64);\n",
				"Returns the logical time of the current transaction.\n"												
			]	
		},
        "block.timestamp": {
			"prefix": "block.timestamp",
			"body": "block.timestamp",			
			"description": [
				"block.timestamp returns (uint64);\n",
				"Returns the starting logical time of the current block."												
			]	
		},
        "rnd.next": {
			"prefix": "rnd.next",
			"body": "rnd.next(${1:[Type limit]})",			
			"description": [
				"rnd.next([Type limit]) returns (Type);\n",
				"Generates a new pseudo-random number.\n\t1. Returns uint256 number.\n\t2. If the first argument limit > 0 then \n\tfunction returns the value in the range \n\t0..limit-1. Else if limit < 0 then the \n\treturned value lies in range limit..-1. \n\tElse if limit == 0 then it returns 0.\n",
				"Examples:",
				"// 1)\nuint256 r0 = rnd.next(); // 0..2^256-1\n// 2)\nuint8 r1 = rnd.next(100);  // 0..99\nint8 r2 = rnd.next(int8(100));  // 0..99\nint8 r3 = rnd.next(int8(-100)); // -100..-1\n"		
			]				
		},
        "rnd.getSeed": {
			"prefix": "rnd.getSeed",
			"body": "rnd.getSeed()",			
			"description": [
				"rnd.getSeed() returns (uint256);\n",
				"Returns the current random seed.\n"	
			]			
		},
        "rnd.setSeed": {
			"prefix": "rnd.setSeed",
			"body": "rnd.setSeed()",			
			"description": [
				"rnd.setSeed(${1:uint256 x});\n",
				"Sets the random seed to x.\n"	
			]			
		},
        "rnd.shuffle": {
			"prefix": "rnd.shuffle",
			"body": "rnd.shuffle(${1:uint someNumber(optional)})",			
			"description": [
				"Randomizes the random seed.\n\n1. Mixes the random seed and someNumber\nrnd.shuffle(uint someNumber);\n",
				"2. Mixes the random seed and the logical time of the current transaction.\nrnd.shuffle();\n"	
			]			
		},
        "selfdestruct": {
			"prefix": "selfdestruct",
			"body": "selfdestruct(${1:address dest_addr})",			
			"description": [
				"selfdestruct(address dest_addr);\n",
				"Creates and sends the message that carries \nall the remaining balance of the current smart \ncontract and destroys the current account.\n"	
			]			
		},
        "sha256": {
			"prefix": "sha256",
			"body": "sha256(${1|TvmSlice slice, bytes b, string str|})",			
			"description": [
				"// (1)\nsha256(TvmSlice slice) returns (uint256)\n// (2) \nsha256(bytes b) returns (uint256)\n// (3)\nsha256(string str) returns (uint256)\n",	
				"1. Compute the SHA-256 hash. If the bit \nlength of slice is not divisible by eight, \nthrows a cell underflow exception. \nReferences of slice are not used to compute \nthe hash. Only data bits located in the \nroot cell of slice are used. 2. Compute the SHA-256 hash only for the \nfirst 127 bytes. If bytes.length > 127 then b[128], \nb[129], b[130] ... elements are ignored.\n 3. Same as for bytes: only the first 127 \nbytes are taken into account.\n"	
			]			
		},
        "gasToValue": {
			"prefix": "gasToValue",
			"body": "gasToValue(${1:uint128 gas}, ${2:int8 wid})",			
			"description": [
				"gasToValue(uint128 gas, int8 wid) returns (uint128 value)\n",	
				"Returns worth of gas in workchain wid. Throws an \nexception if wid doesn't equal 0 and -1.\n"	
			]			
		},
        "valueToGas": {
			"prefix": "valueToGas",
			"body": "valueToGas(${1:uint128 value}, ${2:int8 wid})",			
			"description": [
				"gasToValue(uint128 value, int8 wid) returns (uint128 gas)\n",	
				"Returns how much gas could be bought on value \nnanotons in workchain wid. \nThrows an exception if wid doesn't equal 0 and -1.\n"	
			]			
		}			
    }
}
